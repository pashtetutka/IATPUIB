---
title: "Практика в DuckDB"
author: "pashtet.2003@yandex.ru"
format: 
  md:
    output-file: README.md
---

## Цель работы
 - Изучить возможности СУБД DuckDB для обработки и анализ больших данных
 - Получить навыки применения DuckDB совместно с языком программирования R
 - Получить навыки анализа метаинфомации о сетевом трафике
 - Получить навыки применения облачных технологий хранения, подготовки и анализа данных: Yandex Object Storage, Rstudio Server

## Исходные данные и инструменты

- **ОС:** Windows 10  
- **Среда:** RStudio Server  
- **Язык программирования:** R 4.1  
- **СУБД:** DuckDB  
- **Библиотеки:** `dplyr`, `duckdb`

Исходный набор данных: сетевой трафик (файл `tm_data.pqt`).

## Задание 1: Надите утечку данных из Вашей сети

**Описание:**  
Важнейшие документы с результатами нашей исследовательской деятельности в
области создания вакцин скачиваются в виде больших заархивированных дампов.
Один из хостов в нашей сети используется для пересылки этой информации – он 
пересылает гораздо больше информации на внешние ресурсы в Интернете, чем 
остальные компьютеры нашей сети. Определите его IP-адрес

**Подход к решению:**  
1. Подключиться к локальной базе DuckDB.
2. Загрузить исходные данные о сетевом трафике (`tm_data.pqt`) и создать на их основе таблицу в DuckDB.
3. Выполнить запрос, который:
   - Отбирает источники (`src`), чьи адреса начинаются на `12`, `13` или `14`.
   - Исключает записи, где `dst` также внутренний (то есть начинающийся на `12`, `13` или `14`).
   - Группирует по `src` и сортирует результаты по сумме байт (в порядке убывания).
   - Возвращает первую запись, являющуюся IP-адресом "утекающего" хоста.

**Код:**

```{r}
library(duckdb)
library(dplyr)
```

# Подключение к DuckDB
```{r}
con <- dbConnect(duckdb())
```

# Загрузка и создание таблицы из файла
```{r}
download.file(
    "https://storage.yandexcloud.net/arrow-datasets/tm_data.pqt", 
    destfile = "tm_data.pqt"
)
dbExecute(con, "CREATE TABLE tmdatatable AS SELECT * FROM read_parquet('tm_data.pqt')")
```

# Выполнение запроса
```{r}
res <- dbGetQuery(con, "
  SELECT src
  FROM tmdatatable
  WHERE (src LIKE '12.%' OR src LIKE '13.%' OR src LIKE '14.%')
    AND (dst NOT LIKE '12.%' AND dst NOT LIKE '13.%' AND dst NOT LIKE '14.%')
  GROUP BY src
  ORDER BY SUM(bytes) DESC
  LIMIT 1
")

res
```

**Пример результата:**
```
    src
1 13.37.84.125
```

## Задание 2: Найти утечку данных №2

**Описание:**  
Другой нарушитель настроил автоматическую задачу (через cron) для экспорта содержимого внутренней wiki-системы в нерабочие часы. В результате в определённые часы наблюдается аномально большой объём исходящего трафика во внешние сети. Необходимо определить IP-адрес этой системы. Известно, что IP-адрес данного нарушителя отличается от результата Задания 1.

**Подход к решению:**
1. Определить интервалы времени, когда исходящий трафик во внешние сети максимален.
2. Ориентируясь на нерабочие часы (определяемые аналитиком, в данном случае рассматриваем ранние часы суток), найти хост, генерирующий наибольший объем внешнего трафика в эти часы.
3. Исключить из рассмотрения ранее найденный IP-адрес нарушителя (из Задания 1).
4. Выявить новый IP-адрес.

**Код:**

```{r}
# Анализ трафика по часам
time_stats <- dbGetQuery(con, "
    SELECT 
        time,
        COUNT(*) AS trafictime
    FROM (
        SELECT 
            timestamp,
            src,
            dst,
            bytes,
            (
                (src LIKE '12.%' OR src LIKE '13.%' OR src LIKE '14.%')
                AND (dst NOT LIKE '12.%' AND dst NOT LIKE '13.%' AND dst NOT LIKE '14.%')
            ) AS trafic,
            EXTRACT(HOUR FROM epoch_ms(CAST(timestamp AS BIGINT))) AS time
        FROM tmdatatable
    ) sub
    WHERE trafic = TRUE 
      AND time BETWEEN 0 AND 24
    GROUP BY time
    ORDER BY trafictime DESC;
")

time_stats
```

```{r}
res2 <- dbGetQuery(con, "
    SELECT src
    FROM (
        SELECT src, SUM(bytes) AS total_bytes
        FROM (
            SELECT src, dst, bytes,
                   EXTRACT(HOUR FROM epoch_ms(CAST(timestamp AS BIGINT))) AS time
            FROM tmdatatable
        ) AS sub
        WHERE src <> '13.37.84.125'   -- исключаем IP из Задания 1
          AND (src LIKE '12.%' OR src LIKE '13.%' OR src LIKE '14.%')
          AND dst NOT LIKE '12.%' 
          AND dst NOT LIKE '13.%'
          AND dst NOT LIKE '14.%'
          AND time BETWEEN 1 AND 15    -- нерабочие часы (пример)
        GROUP BY src
    ) AS grp
    ORDER BY total_bytes DESC
    LIMIT 1;
")

res2
```

## Задание 3: Найти утечку данных №3

**Описание:**  
Ещё один нарушитель пересылает большое количество данных наружу через порт, который обычно не используется для такого типа трафика. Необходимо определить IP-адрес этого нарушителя, отличного от тех, что были найдены в предыдущих заданиях.

**Подход к решению:**
1. Исключить из рассмотрения уже найденных нарушителей (из Задания 1 и Задания 2).
2. Рассмотреть внутренние IP-адреса (начинающиеся на `12.`, `13.`, или `14.`), которые отсылают данные во внешние сети.
3. Определить порт, который наиболее аномален по объёму пересылаемых данных:  
   - Для этого для каждого порта вычисляем среднее, максимум и сумму байт.  
   - Рассчитываем разницу между `MAX(bytes)` и `AVG(bytes)` и сортируем порты по этой метрике убывательно.
4. Выявив самый аномальный порт, найдём хост, который генерирует наибольший объём данных через этот порт.

::: {.panel-tabset}

### Создание временной таблицы

```{r}
dbExecute(con, "
    CREATE TEMPORARY TABLE task31 AS
    SELECT src, bytes, port
    FROM tmdatatable
    WHERE (src LIKE '12.%' OR src LIKE '13.%' OR src LIKE '14.%')
      AND src <> '13.37.84.125'  -- исключаем хост из Задания 1
      AND src <> '12.55.77.96'   -- исключаем хост из Задания 2
      AND (dst NOT LIKE '12.%' OR dst NOT LIKE '13.%' OR dst NOT LIKE '14.%');
")
```
  
```{r}
port_stats <- dbGetQuery(con, "
    SELECT port,
           AVG(bytes) AS mean_bytes,
           MAX(bytes) AS max_bytes,
           SUM(bytes) AS sum_bytes,
           (MAX(bytes) - AVG(bytes)) AS Raz
    FROM task31
    GROUP BY port
    HAVING (MAX(bytes) - AVG(bytes)) <> 0
    ORDER BY Raz DESC
    LIMIT 1;
")

port_stats
```

```{r}
host_res <- dbGetQuery(con, "
    SELECT src
    FROM (
        SELECT src, AVG(bytes) AS mean_bytes
        FROM task31
        WHERE port = 37
        GROUP BY src
    ) AS aggregated
    ORDER BY mean_bytes DESC
    LIMIT 1;
")

host_res
```

  
## Оценка результата

В ходе выполнения работ были:

- Загружены и проанализированы большие данные о сетевом трафике из `tm_data.pqt`.
- Применены различные фильтры и агрегирующие функции к данным с использованием DuckDB.
- Успешно решены три поставленных задачи:
  1. Определение хоста, генерирующего наибольший объём исходящего трафика из внутренней сети.
  2. Идентификация хоста, усиливающего трафик в нерабочие часы.
  3. Поиск хоста, отправляющего аномально большой объём данных через нетипичный порт.

## Вывод

В результате работы мы познакомились с возможностями DuckDB и продемонстрировали эффективность данного инструмента для анализа больших данных о сетевом трафике в связке с языком R. Применение облачных технологий, регулярных выражений и агрегирующих запросов позволило быстро и эффективно выявить аномалии и нарушителей в сетевом трафике.
